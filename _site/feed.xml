<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-11-30T18:58:45+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Yundal</title><subtitle>This is my amazing blog:)</subtitle><author><name>Yundal</name><email>susu12356@gmail.com</email></author><entry><title type="html">[운영체제] 1.운영체제</title><link href="http://localhost:4000/cs/os/process-thread/" rel="alternate" type="text/html" title="[운영체제] 1.운영체제" /><published>2024-10-24T00:00:00+09:00</published><updated>2024-10-24T00:00:00+09:00</updated><id>http://localhost:4000/cs/os/process-thread</id><content type="html" xml:base="http://localhost:4000/cs/os/process-thread/"><![CDATA[<h3 id="프로세스">프로세스</h3>

<p>: 메모리에 적재되어 실행중인 프로그램(일, task)이다.</p>

<ul>
  <li>
    <p>각각의 프로세스는 독립된 메모리 공간을 가지며 , 다른 프로세스와 메모리 공간을 공유하지 않는다.</p>

    <table>
      <tbody>
        <tr>
          <td>프로그램</td>
          <td>보조기억장치(SSD, 하드디스크)에 존재하는 실행되기를 기다리는 명령(코드)과 정적인 데이터의 묶음, 쉽게 말하면 코드가 작성되어 있는 파일</td>
        </tr>
        <tr>
          <td>프로세스</td>
          <td>실행중인 프로그램</td>
        </tr>
        <tr>
          <td>프로세서</td>
          <td>명령어를 실행하는 장치 ex)CPU</td>
        </tr>
      </tbody>
    </table>

    <p>### <strong>프로그램이 프로세스가 되는 과정</strong></p>

    <ol>
      <li>
        <p>메모리에 프로세스가 필요로 하는 <strong>재료</strong>들이 올라가야 한다.</p>

        <p><img src="https://prod-files-secure.s3.us-west-2.amazonaws.com/da29a764-c3f4-4c2d-a877-3d3f432b361e/1706b9bf-20cd-481a-ae7d-44b8c6ee7d40/5c99876a-d21b-4d45-a311-204cffe243c5.png" alt="프로세스 메모리 구조" /></p>

        <p>프로세스 메모리 구조</p>

        <ul>
          <li>Stack 영역 [동적]
            <ul>
              <li>함수 호출과 관계되는 지역변수, 매개변수 등을 저장한다.</li>
              <li>함수 호출 시 생성되고 함수가 끝날 시에 반환한다.</li>
            </ul>
          </li>
          <li>Heap 영역 [동적]
            <ul>
              <li>프로그램 실핼 중에 필요에 의해 메모리를 동적으로 할당하는 영역이다.</li>
              <li>Heap에 할당된 메모리 블록은 프로그램이 직접 접근할 수 있는 변수 이름을 가지지 않는다. 예를 들어, <strong>전역 변수</strong>나 <strong>지역 변수</strong>처럼 특정 이름으로 직접 참조되지 않는다. 따라서 <strong>Heap 메모리에 접근</strong>하기 위해서는 <strong>해당 메모리의 주소 값</strong>이 필요하다. 주소 값에 의해서만 참조되고 사용되는 영역이다.</li>
            </ul>
          </li>
          <li>Data 영역
            <ul>
              <li>
                <p>프로그램의 실행과 종료 과정에서 발생한 전역변수와 static 변수, 배열 등을 저장한다.</p>

                <table>
                  <thead>
                    <tr>
                      <th>BSS(Block Started by Symbol) 영역</th>
                      <th><strong>초기화되지 않은 전역 변수</strong>와 <strong>static 변수</strong>가 저장 <code class="language-plaintext highlighter-rouge">int a</code>;</th>
                      <th>프로그램이 시작될 때 자동으로 0으로 초기화 된다.</th>
                      <th>RAM에 저장</th>
                      <th>-</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>GVAR 영역</td>
                      <td><strong>초기화된 전역 변수</strong>와 <strong>static 변수</strong> <code class="language-plaintext highlighter-rouge">int a = 10;</code></td>
                      <td>프로그램 시작 시 초기 값이 필요하기 때문에 초기 값을 ROM에 저장하고 실행중에는 RAM에 로드된다.</td>
                      <td>ROM에 저장</td>
                      <td>초기 값을 기록해야 되므로 BSS보다 상대적으로 큰 공간을 차지한다.</td>
                    </tr>
                  </tbody>
                </table>

                <p><strong>BSS와 GVAR(Data) 구분의 이유</strong></p>

                <p><strong>메모리 파일 크기의 효율성 때문이다.</strong></p>

                <p><strong>BSS 영역은</strong> 초기화 되지 않은 변수를 0으로 초기화 할 뿐 이기에 ROM에 저장되지 않고, 실행시점에 RAM에 메모리만 할당해주면 된다.</p>

                <p>반면, GVAR 영역은 초기 값을 기록해야 하기에 ROM에 저장하고, 프로그램이 실행될 때 RAM에 로드해야 한다.</p>

                <p>여기서 초기화 되지 않은 데이터 까지 모두 ROM에 저장한다면, 프로그램의 크기가 커질 것이다.</p>
              </li>
            </ul>
          </li>
          <li>Text/Code 영역
            <ul>
              <li>실행 명령을 포함하는 코드들이 들어가는 부분으로 컴파일한 프로그램(기계어)가 저장된다.</li>
              <li>읽기 전용이다 .</li>
            </ul>
          </li>
        </ul>
      </li>
    </ol>
  </li>
</ul>]]></content><author><name>Yundal</name><email>susu12356@gmail.com</email></author><category term="cs" /><category term="os" /><summary type="html"><![CDATA[GitHub Blog를 만들어보았다.]]></summary></entry><entry><title type="html">[컴퓨터구조] 1.컴퓨터의 구성</title><link href="http://localhost:4000/cs/architecture/computer-system/" rel="alternate" type="text/html" title="[컴퓨터구조] 1.컴퓨터의 구성" /><published>2024-10-14T00:00:00+09:00</published><updated>2024-10-14T00:00:00+09:00</updated><id>http://localhost:4000/cs/architecture/computer-system</id><content type="html" xml:base="http://localhost:4000/cs/architecture/computer-system/"><![CDATA[<h2 id="컴퓨터-시스템">컴퓨터 시스템</h2>

<p>컴퓨터 시스템은 개념적으로는 다음 3가지의 결합으로 이루어진다 :</p>

<ul>
  <li>하드웨어</li>
  <li>소프트웨어</li>
  <li>펌웨어</li>
</ul>

<h3 id="하드웨어hardware"><strong>하드웨어(hardware)</strong></h3>
<hr />
<p>전기적인 신호로 구성된 정보 즉, 데이터를 이동하거나 처리하는 물리적인 실체를 의미한다.</p>

<ul>
  <li>외관과 용도 막론하고 컴퓨터를 이루는 핵심 부품은 크게 다르지 않다. 주로 CPU, 기억장치, 주변장치(CPU와 메모리를 제외한 나머지)로 구성된다. 각 구성요소들은 시스템 버스로 연결되어 있으며, 하드웨터의 품질은 컴퓨터의 정보 처리 능력을 결정한다.</li>
</ul>

<p><img src="/assets/images/post/ca-01-1.png" alt="ca-01-1" /></p>

<h4 id="하드웨어-구성요소">하드웨어 구성요소</h4>
<hr />
<h5 id="cpucentral-processing-unit란">CPU(Central Processing Unit)란?</h5>

<p>: 모든 컴퓨팅 장치의 두뇌 역할을 한다. 운영체제 및 애플리케이션을 시행하는데 필요한 모든 컴퓨팅 작업을 처리한다. CPU는 메모리에서 명령을 가져와 필요한 작업을 수행한 다음 출력을 다시 메모리로 보낸다.</p>

<h6 id="cpu-기술의-발전">CPU 기술의 발전</h6>
<ul>
  <li>마이크로 프로세서
    <ul>
      <li>
        <p>전체 CPU를 단일 IC칩에 결합하여 컴퓨터의 접근성을 높였고, 이는 개인용 컴퓨터의 개발로 이어졌다.</p>

        <p>→ 과거에는 CPU가 여러 개의 부품으로 나누어져서 작동했다. 마이크로프로세서 기술이 발전하면서, 이런 역할을 모두 하나의 작은 칩(IC) 안에 넣을 수 있게 되었다. <br />
  결과적으로 컴퓨터가  작아지면서 책상에 올려놓을 수 있는 크기의 개인용 컴퓨터를 개발할 수 았었다. 1970년대 후반과 1980년대 초반에 등장한 Apple II나 IBM PC 같은 초기 개인용 컴퓨터의 출현으로 이어졌다.</p>
      </li>
    </ul>
  </li>
  <li>현대식 프로세서
    <ul>
      <li>스마트폰 및 태블릿과 같은 모바일 디바이스들이 등장하면서 전력 효율성이 중요해졌다. 따라서 이 를 위한 저전력 및 에너지 효율적인 CPU를 개발하고 있다.</li>
    </ul>
  </li>
</ul>

<h6 id="cpu의-구성요소">CPU의 구성요소</h6>
<ul>
  <li>제어장치
    <ul>
      <li>
        <p>명령 처리를 관리하고 CPU 내부 및 다른 컴퓨터의 구성요소들 간의 데이터 흐름을 조정한다. 즉, <strong>컴퓨터 시스템의 각 구성 요소들이 올바르게 동작하도록</strong> 필요한 작업을 다른 CPU 구성 요소에 지시하는 역할을 한다.</p>

        <p><strong>1️. 명령어 가져오기(Fetch</strong>) : 메모리에서 프로그램의 명령어를 하나씩 가져온다.</p>

        <p><strong>2️. 명령어 해석(Decode)</strong> :  그 명령이 무엇을 의미하는지 해석한다.</p>

        <p>⇒ 이를 명령어 사이클이라고 한다.</p>

        <p><strong>3️. 명령 실행(Execute)</strong> : 명령에 따라 CPU와 다른 장치들에게 어떤 작업을 해야 할지 지시한다. 예 ) 데이터 이동, 계산 수행</p>

        <p><strong>4️. 결과 저장</strong> : 실행 결과를 다시 메모리에 저장하거나 다음 작업으로 넘긴가.  </p>

        <p>→ 이 과정들을 지휘한다고 보면된다. <br /><br /></p>
      </li>
      <li>
        <p>클럭 신호를 받아 그 신호에 맞춰 명령어 처리의 각 단계를 <strong>동기화</strong> 한다.</p>

        <p class="notice--info"><strong>클럭신호</strong><br />
  CPU 안에서 일정한 속도로 반복적으로 발생하는 전기적 신호이다.  시계가 ‘틱, 톡’하는 것처럼,  “틱틱”하는 리듬을 일정한 간격으로 제공하면서 컴퓨터가 작업을 언제 시작하고, 언제 끝낼지를 알려주는 역할을 한다.<br /><br />
  컴퓨터는 위에 말한 4가지 과정을 거쳐 명령을 처리하는데, 제어장치는 그 단계들이 클럭 신호에 맞춰 정확한 순서로 실행되도록 조율하는 역할을 한다. 
  예를 들어, 클럭 신호가 ‘틱’ 할 때 명령어를 가져오고, ‘톡’ 할 때 그 명령어를 해석한다. <br /><br />
  클럭의 속도<br />
      ◦ 클럭 신호의 속도는 주파수로 표현되는데, 주파수는 1초에 클럭이 몇 번 진동하는지를 나타낸다. 이를 헤르츠(Hz)단위로 측정하며,  CPU에서 실행할 수 있는 초당 명령 수를 결정한다. 1GHz 는 1초에 10억번의 클럭 사이클이 발생한다는 의미이다.<br /><br />
      ◦ 주파수가 높을수록, 클럭 신호의 속도가 빠르다는 의미이며, 이는 더 많은 명령을 빠르게 처리할 수 있다.</p>
      </li>
    </ul>
  </li>
  <li>
    <p>연산장치(ALU, Arithmetic Logic Unit) : 컴퓨터의 수학적 계산과 논리적 연산을 처리하는 장치이다.</p>

    <ul>
      <li>기본 산술 연산(더하기, 빼기, 곱하기, 나누기)</li>
      <li>논리 연산(<em>AND</em>, <em>OR</em>, <em>NOT</em>)
        <ul>
          <li>두 값이 같은지(=), 더 큰지(&gt;) 혹은 더 작은지(&lt;)를 비교하거나 <em>AND</em>, <em>OR</em>, <em>NOT</em>과 같은 논리 연산을 처리한다.</li>
        </ul>
      </li>
      <li>비트연산
        <ul>
          <li>두 값의 이진수 형태를 비교한다.<br /><br /></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>레지스터(Register) : CPU 내부에 있는 소형 고속 저용량 저장 장치이다.</p>

    <ul>
      <li>즉시 저장
        <ul>
          <li>CPU가 데이터를 처리할 때, 필요한 정보를 일시적으로 저장해야 할 때, 즉시 레지스터로 저장할수 있다.</li>
        </ul>
      </li>
      <li>저용량
        <ul>
          <li>빠르게 작동하기 위해서 용량이 작다 .보통 몇 비트 ~ 수십 비트 정도 크기의 데이터를 저장할 수 있다.</li>
        </ul>
      </li>
      <li>고속
        <ul>
          <li>CPU와 바로 연결되어 있다. 따라서 메모리에 접근하여 데이터를 불러오는 것보다 훨씬 빠르다.</li>
        </ul>
      </li>
      <li>종류
        <ul>
          <li>데이터 레지스터 :  연산장치가 연산을 수행할 때 필요한 숫자나 정보를 저장한다.</li>
          <li>명령어 레지스터(IR, Instructioin Register) : 현재 실행 중인 명령어를 저장한다. CPU는 IR에서 명령을 읽고 해석한다.</li>
          <li>주소 레지스터(MAR, Memory Address Register) : 메모리에서 데이터을 읽어오거나 데이터를 쓸(write) 때, 해당 메모리의 주소를 저장한다.</li>
          <li>누산기(ACC, Accumulator) : 특수 레지스터로 연산장치가 계산을 끝낸 결과를 누산기에 저장한다.<br /><br /></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>CPU 내부 버스</p>

    <p><img src="/assets/images/post/ca-01-2.png" alt="ca-01-2" /></p>

    <p>CPU 내부에서 데이터를 주고 받는 연결통로이다. 즉, CPU 내부의 여러 부품들이 서로 <strong>소통</strong>할 수 있게 해주는 고속 통신로이다. 실제로는 여러 개의 전성 또는 회로로 이루어져있다. 버스가 얼마나 빠르게 데이터를 전달할 수 있느냐에 따라 CPU 처리속도가 결정된다.</p>

    <ul>
      <li>버스 종류
        <ul>
          <li>데이터 버스(Data Bus) : 실제 데이터를 전달하는 통로이다. CPU가 메모리에 접근할 때, 데이터를 주고받는 통로가 이 데이터 버스이다. [양방향]</li>
          <li>주소 버스(Address Bus) : 메모리나 입출력 장치의 주소를 전달한다. 앞서 MAR에서 잠깐 언급했듯, CPU는 메모리에서 필요한 데이터를 읽거나 쓴다. 이 때 그 데이터 저장된 위치가 필요한데, 이 주소 버스가 CPU가 어디로 가야할 지 알려주는 역할을 한다. [일방향]</li>
          <li>제어 버스(Control Bus) : 명령어와 상태 신호를 전달한다. CPU가 다른 장치과 통신할 때, 데이터와 주소만 주고는 것이 아니라 무엇을 할지에 대한 정보도 필요하다. 예를 들어, 데이터를 읽을 지, 쓸 지 혹은 장치가 준비가 된 상태인지 등을 제어버스를 통해 전달한다. [양방향]</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h5 id="주기억장치란main-memory란">주기억장치란(Main Memory)란?</h5>
<hr />
<p>: 데이터를 저장하고 필요한 정보를 CPU가 빠르게 접근할 수 있도록 해주는 장치로 크게 RAM(Random Access Memory)과 ROM(Read Only Memory)이 있다. 메모리라는 용어는 보통 RAM를 지칭한다.</p>

<h6 id="ramrandom-access-memory">RAM(Random Access Memory)</h6>

<p>: 휘발성 메모리로 CPU가 데이터를 즉시 처리할 수 있도록 임시로 저장하는 곳이다.</p>

<ul>
  <li>SRAM(Static RAM)</li>
  <li>DRAM(Dynamic RAM)</li>
</ul>

<h6 id="romread-only-memory">ROM(Read Only Memory</h6>

<p>: 비휘발성 메모리로, 컴퓨터가 부팅될 때 필요한 기본적인 시스템 정보를 저장하는 장치이다.<br /><br /></p>

<h5 id="보조-기억장치secondary-memory란">보조 기억장치(Secondary Memory)란?</h5>
<hr />
<p>: 앞서 언급한 주기억장치는 휘발성 메모리로 전원이 꺼지면, 데이터가 사라지고. 가격이 비싸기에 용량이 작다. 이를 보완하여 용량이 크고, 비휘발성인 저장 장치를 만들었는데, 이를 보조기억장치라고 한다.</p>

<ul>
  <li>보조기억장치 종류
    <ul>
      <li>하드디스크</li>
      <li>SSD</li>
      <li>CD-ROM<br /><br /></li>
    </ul>
  </li>
</ul>

<h5 id="입출력장치란">입출력장치란?</h5>

<p>: 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환하는 장치를 의미한다.</p>

<ul>
  <li>입출력장치 종류
    <ul>
      <li>마이크</li>
      <li>스피커</li>
      <li>프린터</li>
      <li>마우스</li>
      <li>키보드<br /></li>
    </ul>
  </li>
</ul>

<p class="notice--warning"><strong>QUESTION</strong><br /><br />
Q. 보조기억장치도 컴퓨터 외부에 연결되어 있으면서 내부와 정보를 교환하는데, 그렇다면 보조기억장치도 입출력장치라고 할 수 있지 않나요?<br />
A. 보조기억장치와 입출력장치를 ‘컴퓨터 주변에 붙여있는 장치’라는 의미에서 주변장치라 통칭하기도 한다. “보조기억장치는 입출력장치에 비해 메모리를 보조하는 역할을 수행한다.”정도로 이해하자!</p>

<h4 id="단위">단위</h4>

<ul>
  <li>비트(bit) : 정보를 구성하는 최소단위</li>
  <li>바이트(byte) : 정보르 표현하는 최소 단위
    <ul>
      <li>8 bit = 1byte</li>
    </ul>
  </li>
  <li>워드(word) : CPU에서 한 번에 처리할 수 있는 비트의 크기
    <ul>
      <li>= 메모리에서 데이터를 한 번 읽어올 때 크기</li>
      <li>
        <p>= 연산장치가 다루는 데이터의 크기</p>

        <p>예) intel의 CPU 워드 크기는 32bit or 64bit</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="소프트웨어">소프트웨어</h3>
<hr />
<p>컴퓨터 하드웨어가 작동하도록 명령을 내리는 프로그램과 데이터의 집합이다. 쉽게 말해서 컴퓨터를 움직이게 하는 설계도이자 명령어이다.</p>

<h4 id="시스템-소프트웨어-system-software">시스템 소프트웨어 (System Software)</h4>
<ul>
  <li>운영체제와 같이 하드웨어를 관리하고 다른 소프트웨어가 동작할 수 있도록 환경을 제공한다.
    <ul>
      <li>Windows, macOS, Linux, Android</li>
    </ul>
  </li>
</ul>

<h4 id="응용-소프트웨어-application-software">응용 소프트웨어 (Application Software)</h4>
<ul>
  <li>사용자가 특정 작업을 수행하도록 도와주는 소프트웨어이다.
    <ul>
      <li>웹 브라우저(Chrome), 워드 프로세서(MS Word), 게임, 메신저 등</li>
    </ul>
  </li>
</ul>

<h4 id="미들웨어-middleware">미들웨어 (Middleware)</h4>
<ul>
  <li>시스템 소프트웨어와 응용 소프트웨어 사이에서 <strong>데이터를 연결</strong>하고 <strong>호환성을 제공</strong>하는 소프트웨어이다.
    <ul>
      <li>데이터베이스 미들웨어, 메시지 큐</li>
    </ul>
  </li>
</ul>

<h3 id="펌웨어">펌웨어</h3>
<hr />
<p>하드웨어의 동작을 제어하는 소프트웨어로, 하드웨어 내부에 내장되어 있다. 소프트웨어와 하드웨어의 <strong>중간 역할</strong>을 수행하여 <strong>하드웨어와 소프트웨어가 원활하게 동작</strong>할 수 있도록 돕는다. 하드웨어 <strong>초기화, 제어, 보안 강화</strong> 등의 기능을 담당하며, <strong>플래시 메모리</strong>에 저장되어 업데이트를 통해 기능을 개선할 수 있다.</p>

<ul>
  <li><strong>스마트폰 펌웨어</strong>
    <ul>
      <li>카메라, 센서, 배터리 등 <strong>하드웨어 장치를 제어</strong>하고 운영체제와 연동한다.</li>
    </ul>
  </li>
  <li><strong>가전 제품</strong>
    <ul>
      <li>TV, 세탁기, 전자레인지 등에서는 펌웨어가 <strong>기능을 제어</strong>하고 <strong>UI 화면</strong>을 표시한다.</li>
    </ul>
  </li>
</ul>]]></content><author><name>Yundal</name><email>susu12356@gmail.com</email></author><category term="cs" /><category term="architecture" /><summary type="html"><![CDATA[GitHub Blog를 만들어보았다.]]></summary></entry><entry><title type="html">[Minimal-Mistakes] github 블로그 만들기</title><link href="http://localhost:4000/github-blog/log/first-post/" rel="alternate" type="text/html" title="[Minimal-Mistakes] github 블로그 만들기" /><published>2024-10-11T00:00:00+09:00</published><updated>2024-10-11T00:00:00+09:00</updated><id>http://localhost:4000/github-blog/log/first-post</id><content type="html" xml:base="http://localhost:4000/github-blog/log/first-post/"><![CDATA[<h5 id="github-blog-서비스인-githubio-만들기">GitHub Blog 서비스인 github.io 만들기</h5>
<hr />
<p>처음에는 노션에다가 작성해오다가, 다른 플랫폼으로 옮기고 싶어서 velog를 만들었다.<br />
하지만 손이 자주 가지 않았고, 색다른 플랫폼을 사용해보고 싶었다. <br />
그러던 중 만들기 쉽지 않다는 GitHub Blog를 개설하고 싶다는 생각이 들어 도전하게 되었다.</p>

<p>블로그 사이트에 접속해서 글을 작성하면 되는 다른 플랫폼에 비해, 레포지토리를 만들어서 원하는 테마를 적용하고, 커스터마이징 하는 과정이 필요했다. 정말 쉽지 않았다.</p>

<p>그냥 기존이 사용하던 velog를 계속 사용할까 하는 생각이 정말 계속 들었지만, 한 번 끝을 보고 싶었다!</p>

<p>결과적으로 이렇게 성공적으로 블로그를 만들었는데 뿌듯하다. 
힘들게 만든 블로그인 만큼 손이 자주 갈 것 같다!</p>

<p>앞으로 노션, velog에 작성한 글들을 하나씩 옮겨오는 작업을 할 예정이다. 
시간이 좀 걸리겠지만, 블로그를 채워나갈 생각에 아주 기분이 좋다! 😎</p>

<p>참고한 사이트 :</p>
<blockquote>

  <p><a href="https://devinlife.com/howto/">취미로 코딩하는 개발자 </a><br />
<a href="https://github.com/mmistakes/minimal-mistakes">minimal-mistakes official github</a></p>
</blockquote>]]></content><author><name>Yundal</name><email>susu12356@gmail.com</email></author><category term="github-blog" /><category term="log" /><summary type="html"><![CDATA[GitHub Blog를 만들어보았다.]]></summary></entry></feed>